"""
.. module:: controller
    :platform: Unix, Windows
    :synopsis: Generates events according input of various controllers connected to the game.
"""
#Protected keys: enter, escape
#

import pygame
import events
import controlSettingScreen

BLACK    = (   0,   0,   0)
WHITE    = ( 255, 255, 255)

def equal_input_source(input1, input2):
    #Keyboard key:
    #KEYDOWN == KEYUP, same key_index --> same key toggled
    if input_is_a_key(input1) and input_is_a_key(input2):
        return (input1.key == input2.key)
    #Joystick button:
    #Similar to keyboard button, but one must check if the
    #toggled button is on the same joystick
    if input_is_a_joystickbutton(input1) and input_is_a_joystickbutton(input2):
        return (input1.button == input2.button and
                input1.joy == input2.joy)
    #Joystick axis (or axis direction):
    #distinguish between axis which is slanted left vs right
    #(or top vs. bottom)
    #Example: when self and other_input are both slanted left,
    #have similar axis index and joystick index, then the same
    #axis was moved
    if input_is_a_joystickaxis(input1) and input_is_a_joystickaxis(input2):
        offset = 0.04 #Filter to small values
        return (((input1.value > offset and input2.value > offset) or
                (input1.value < offset and input2.value < offset)) and
                input1.axis == input2.axis and
                input1.joy == input2.joy)
    #Joystickhat
    if input_is_a_joystickhat(input1) and input_is_a_joystickhat(input2):
        x_value1, y_value1 = input1.value
        x_value2, y_value2 = input2.value
        return (x_value1 == x_value2 and
                y_value1 == y_value2 and
                input1.hat == input2.hat and
                input1.joy == input2.joy)
    else:
        return False

def input_is_a_key(inpt):
    return (inpt.type == pygame.KEYDOWN or inpt.type == pygame.KEYUP)

def input_is_a_joystickbutton(inpt):
    return (inpt.type == pygame.JOYBUTTONDOWN or inpt.type == pygame.JOYBUTTONUP)
    
def input_is_a_joystickaxis(inpt):
    return inpt.type == pygame.JOYAXISMOTION

def input_is_a_joystickhat(inpt):
    return inpt.type == pygame.JOYHATMOTION

class Actions:
    MOVE_LEFT = 1
    MOVE_RIGHT = 2
    JUMP = 3
    AIM_X = 4
    AIM_MINUS_X = 5
    AIM_Y = 6
    AIM_MINUS_Y = 7

def is_aim_action(event_action):
    return (event_action == Actions.AIM_X or
            event_action == Actions.AIM_Y or
            event_action == Actions.AIM_MINUS_X or
            event_action == Actions.AIM_MINUS_Y)

def is_movement_action(event_action):
    return (event_action == Actions.JUMP or
            event_action == Actions.MOVE_LEFT or
            event_action == Actions.MOVE_RIGHT)

# This is a simple class that will help us print to the screen
class TextPrint:
    def __init__(self):
        self.reset()
        self.font = pygame.font.Font(None, 30)

    def print_(self, screen, textString):
        textBitmap = self.font.render(textString, True, BLACK)
        screen.blit(textBitmap, [self.x, self.y])
        width, height = self.font.size(textString);
        self.x += width
        return width

    def println_(self, screen, textString):
        self.print_(screen, textString)
        width, height = self.font.size(textString);
        self.x -= width
        self.line_break()
        return width

    def carriage_return(self, width):
        self.x -= width

    def line_break(self):
        self.y += self.line_height

    def reset(self):
        self.x = 10
        self.y = 10
        self.line_height = 30
        
    def indent(self):
        self.x += 10

    def unindent(self):
        self.x -= 10

class InputController:
    """InputController manages connected controllers and takes events generated by them sending other events to the game.

    :Attributes:
        - *event_manager* (events.EventManager): event manager
        - *joystick* (pygame.joystick.Joystick): game pad
    """
    def __init__(self, screen, event_manager):
        #Register InputController, so it can handle events
        self.event_manager = event_manager
        self.event_manager.register_listener(self)
        #Needed for custom control screen render
        #To store controlls
        self.actions_map = {}
        self.use_mouse_to_aim_and_fire = False
        self.use_hat_to_aim = -1
        self.use_hat_to_move = -1
        self.use_default_controls = False
        self.controls_ready = False
        self.control_setting_screen = controlSettingScreen.ControlSettingScreen(screen)
        #Register game pads that are connected
        #Always needed to get a joystick work
        pygame.joystick.init()
        joystick_count = pygame.joystick.get_count()
        for i in range(joystick_count):
            joystick = pygame.joystick.Joystick(i)
            joystick.init()

    def notify(self, event):
        if isinstance(event, events.TickEvent):
            for event in pygame.event.get():
                #Common events
                if event.type == pygame.VIDEORESIZE:
                    resize_ev = events.ResizeWindowEvent(event.w, event.h)
                    self.event_manager.post(resize_ev)
                if event.type == pygame.QUIT:
                    quit_ev = events.QuitEvent()
                    self.event_manager.post(quit_ev)
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        quit_ev = events.QuitEvent()
                        self.event_manager.post(quit_ev)

                #Controls ready, input events are sent to the game
                if self.controls_ready:
                    #Pause
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_RETURN: #K_RETURN is the enter key
                            self.event_manager.post(events.TogglePauseEvent())
                    #Handle events generated by mouse
                    if self.use_mouse_to_aim_and_fire:
                        if event.type == pygame.MOUSEMOTION:
                            direction_X, direction_Y = pygame.mouse.get_pos()
                            mouse_ev = events.MouseMoved(direction_X, 
                                                         direction_Y)
                            self.event_manager.post(mouse_ev)
                        elif event.type == pygame.MOUSEBUTTONDOWN:
                            attack_request_ev = events.MouseButtonDown()
                            self.event_manager.post(attack_request_ev)
                    #Handle hats
                    if self.use_hat_to_aim > -1:
                        if event.type == pygame.JOYHATMOTION:
                            if event.hat == self.use_hat_to_aim:
                                input_event = events.SentInputAction(Actions.AIM_X, event)
                                self.event_manager.post(input_event)
                    if self.use_hat_to_move > -1:
                        if event.type == pygame.JOYHATMOTION:
                            if event.hat == self.use_hat_to_move:
                                input_event = events.SentInputAction(Actions.JUMP, event)
                                self.event_manager.post(input_event)
                    #Handle other control events
                    if (self.key_used(event)):
                        action = self.determine_action(event)
                        if action:
                                input_event = events.SentInputAction(action, event)
                                self.event_manager.post(input_event)

                #If custom keys are not initialized
                else:
                    self.control_setting_screen.draw()
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        action = self.control_setting_screen.hit_ui_element(event.pos)
                        if (action): #If UI element was hit
                            #Move with hat deactivate
                            if (action == controlSettingScreen.SelectedUI.MOVE_WITH_HAT and
                                 self.use_hat_to_move > -1):
                                self.use_hat_to_move = -1
                                self.control_setting_screen.activate_move_btns()
                                self.control_setting_screen.deactivate_hat_move_btn()
                            #Aim with hat deactivate
                            elif (action == controlSettingScreen.SelectedUI.AIM_WITH_HAT and
                                 self.use_hat_to_aim > -1):
                                self.use_hat_to_aim = -1
                                self.control_setting_screen.activate_aim_btns()
                                self.control_setting_screen.deactivate_hat_aim_btn()
                            #Mouse aim toggle
                            elif (action == controlSettingScreen.SelectedUI.AIM_WITH_MOUSE):
                                if self.use_mouse_to_aim_and_fire:
                                    self.use_mouse_to_aim_and_fire = False
                                    self.control_setting_screen.activate_aim_btns()
                                    self.control_setting_screen.deactivate_mouse_aim_btn()
                                else:
                                    self.use_mouse_to_aim_and_fire = True
                                    self.control_setting_screen.deactivate_aim_btns()
                                    self.control_setting_screen.activate_mouse_aim_btn()
                            #Default controls toggle
                            elif (action == controlSettingScreen.SelectedUI.USE_DEFAULT_CONTROLS):
                                self.use_default_controls = (not self.use_default_controls)
                    action = self.control_setting_screen.currently_selected
                    if event.type == pygame.JOYHATMOTION:
                        #Aim with hat activate
                        if (action == controlSettingScreen.SelectedUI.AIM_WITH_HAT and
                             not event.hat == self.use_hat_to_aim):
                            self.use_hat_to_aim = event.hat
                            self.control_setting_screen.deactivate_aim_btns()
                            self.control_setting_screen.activate_hat_aim_btn()
                        #Move with hat activate
                        elif (action == controlSettingScreen.SelectedUI.MOVE_WITH_HAT and
                             not event.hat == self.use_hat_to_move):
                            self.use_hat_to_move = event.hat
                            self.control_setting_screen.deactivate_move_btns()
                            self.control_setting_screen.activate_hat_move_btn()
                    if (event.type != pygame.MOUSEMOTION and #Filter not relevant
                          event.type != pygame.ACTIVEEVENT and
                          event.type != pygame.VIDEORESIZE and
                          event.type != pygame.VIDEOEXPOSE and
                          event.type != pygame.MOUSEBUTTONUP and
                          event.type != pygame.JOYBUTTONUP):
                        if (not self.key_used(event) and -1<action and action<8):
                            self.save_key(event, action)
                        #Done ?
                        if (controlSettingScreen.SelectedUI.READY == self.control_setting_screen.currently_selected):
                            self.event_manager.post(events.TogglePauseEvent())
                            self.controls_ready = True
                            if self.use_default_controls:
                                self.init_default_controls()
                            if self.use_mouse_to_aim_and_fire:
                                self.remove_aim_controls()
                            elif self.use_hat_to_aim > -1:
                                self.remove_aim_controls()
                                self.event_manager.post(events.ToggleContinuousAttack())
                            else:
                                self.event_manager.post(events.ToggleContinuousAttack())
                            if self.use_hat_to_move > -1:
                                self.remove_movement_controls()
                            self.control_setting_screen = None

    def init_default_controls(self):
        self.actions_map.clear()
        self.actions_map[Actions.JUMP] = pygame.event.Event(pygame.KEYDOWN, key=pygame.K_w)
        self.actions_map[Actions.MOVE_LEFT] = pygame.event.Event(pygame.KEYDOWN, key=pygame.K_a)
        self.actions_map[Actions.MOVE_RIGHT] = pygame.event.Event(pygame.KEYDOWN, key=pygame.K_d)
        self.use_hat_to_aim = -1
        self.use_hat_to_move = -1
        self.use_mouse_to_aim_and_fire = True

    def determine_action(self, inpt):
        for action, control in self.actions_map.iteritems():
            if equal_input_source(control, inpt):
                return action
        return None

    def save_key(self, event, action):
        if (event.type == pygame.JOYBUTTONDOWN or
            event.type == pygame.JOYAXISMOTION or
            event.type == pygame.KEYDOWN):
            if event.type == pygame.KEYDOWN:
                if not(event.key == pygame.K_BACKSPACE or
                       event.key == pygame.K_ESCAPE or
                       event.key == pygame.K_RETURN):
                    self.actions_map[action] = event
            elif event.type == pygame.JOYAXISMOTION:
                if abs(event.value) > 0.5:
                    self.actions_map[action] = event
            else:
                self.actions_map[action] = event

    def key_used(self, control):
        """Is control already mapped to action.
        """
        for value in self.actions_map.itervalues():
            if equal_input_source(control, value):
                return True
        return False

    def remove_aim_controls(self):
        '''Remove all aim controls from action_map.
        '''
        to_remove = list()
        for action in self.actions_map.iterkeys():
            if is_aim_action(action):
                to_remove.append(action)
        for r in to_remove:
            del self.actions_map[r]

    def remove_movement_controls(self):
        '''Remove all movement controls from action_map.
        '''
        to_remove = list()
        for action in self.actions_map.iterkeys():
            if is_movement_action(action):
                to_remove.append(action)
        for r in to_remove:
            del self.actions_map[r]
